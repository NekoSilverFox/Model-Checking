模型验证（Model Checking）是验证系统是否满足某些规格的自动化方法，在计算机科学和软件工程中非常常用。它尤其适用于并发系统的验证，如硬件设计、通信协议等。而时序逻辑是其中的重要基础，用来描述系统行为的时间属性。

> 内容参考：
>
> - E. M.Clarke, O. Grumberg, D.Peled. Model checking. 1999
> - Ю.Г.Карпов. Model checking. Верификация параллельных и распределенных программных систем // БХВ. Петербург, 2010
> - 维基百科

[toc]



# Kripke结构

**克里普克结构（或称Kripke结构）**是[迁移系统](https://zh.wikipedia.org/wiki/Transition_system)的一个变种，最初由索尔·克里普克提出，用于在模型检测中表示一个系统的行为。克里普克结构本身是一个[图](https://zh.wikipedia.org/wiki/图_(数学))，其**结点表示系统可达的状态**，**其边表示状态的迁移**。 有一个标号函数将结点与结点所具有的性质的集合映射起来。[时序逻辑](https://zh.wikipedia.org/wiki/时间逻辑)传统上是由克里普克结构进行解释的。

<img src="doc/img/1-s2.0-S0167642314002846-gr001.gif" alt="Sound and complete timed CTL model checking of timed Kripke structures and  real-time rewrite theories - ScienceDirect" style="zoom:150%;" />

**形式化定义：**

设 **AP 为 原子命题的集合**，比如：包含变量、常量和谓词符号的布尔表达式。 将一个定义在 *AP* 上的克里普克结构定义为一个[四元组](https://zh.wikipedia.org/wiki/多元组) $M =(S, S_0, R, L)$，其中：

- $S$ 是有限状态集合

- $S_0 ⊆ S$ 是初始状态集合 ，有时候 $S_0$ 也被写为 $I$

- $R ⊆ S × S$ 迁移（变迁）关系，即对任意状态 $s ∈ S$，存在状态 $s'∈S$，使得 $R(s,s')$为真。其中 *R* 是一个左部满射的[多值函数](https://zh.wikipedia.org/wiki/多值函数)

    即 $∀s ∈ S, ∃s' ∈ S$ 使得 $ (s,s') ∈ R$

- $L: S →2^{AP}$ 是标记函数（或称“解释函数”） ，他标记在改状态下为真的原子命题集合

> 多值函数（英语：multivalued function, multifunction）为一数学名词，是一种二元关系。其中，定义域
> X 中的每一个元素都对应陪域 Y 中的**至少**一个元素。
>
> ![img](doc/img/200px-Multivalued_function.svg.png)

**执行路径 ρ**：表示系统的状态序列，即系统随时间的演化

**单词 ω** ：是对应执行路径上标签的序列，表示系统在每个状态下原子命题的真值。

由于 *R* 是一个[多值函数](https://zh.wikipedia.org/wiki/多值函数)，因此通过克里普克结构，总是能够构建一个无穷路径。[死锁](https://zh.wikipedia.org/wiki/死锁)状态可以建模为仅存在一条指向自身的的出边。

---

**🌰 例子 🌰**

![img](doc/img/300px-KripkeStructureExample.svg.png)

设原子命题集合 $AP ={p, q}$。 p和q可以模拟任意可以由克里普克结构建模的系统中的布尔命题。

右图表示了一个克里普克结构 $M =(S, I, R, L)$，其中：

- 状态集合，$S = {S_1, S_2, S_3}$
- 初始状态集合，$S_0 = {S_1}$
- 状态转换关系，表示系统从一个状态可以转移到另一个状态。$R = {(S_1, S_2), (S_2,S_1), (S_2,S_3), (S_3、S_3)}$
- 标签函数，给每个状态分配一组原子命题。$L = {(S_1, {p, q}), (S_2, {q}), (S_3, {p})}$

**执行路径 ρ**：

Kripke 结构的**执行路径**表示系统的状态序列，即系统随时间的演化，系统运行经历过的路径。在这个例子中，执行路径 ρ 可以为：
$$
\rho = S_1, S_2, S_1, S_2, S_3, S_3, S_3, \dots
$$
这条路径表明系统首先从状态 $S_1$ 开始，接着转移到状态 $S_2$ ，然后又回到 $S_1$ ，再转移到 $S_2$ ，接着到达 $S_3$ ，并无限次保持在状态 $S_3$ 。。。。

**单词 ω** ：是对应执行路径上标签的序列，表示系统在每个状态下原子命题的真值。在这个例子中，标签序列为：
$$
ω={p,q},{q},{p,q},{q},{p},{p},{p},\dots
$$
每个集合 $\{p, q\}, \{q\}, \dots$ 对应路径上的每个状态的标签：

- 在 $S_1$ 时，标签是 {p,q}，
- 在 $S_2$ 时，标签是 {q}，
- 在 $S_3$ 时，标签是 {p}。



# 弗洛伊德-霍尔逻辑

**Метод Флойда-Хоара**（Floyd-Hoare Logic，弗洛伊德-霍尔逻辑）是由 **罗伯特·弗洛伊德（Robert Floyd）** 和 **托尼·霍尔（Tony Hoare）** 提出的，用于**验证程序正确性**的形式化方法。这个方法主要用于证明**命令式程序**的部分正确性，尤其适用于带有**循环、条件语句**等结构的程序。

**核心思想：**

Флойда-Хоара 方法的核心是通过**逻辑断言（assertions）来描述程序在不同执行点上的状态，并通过推理规则**验证程序是否符合预期的行为。整个逻辑系统基于**霍尔三元组（Hoare Triple）**，这个三元组描述了在程序执行的不同阶段前后的条件。

## Hoare 三元组

一个 **Hoare 三元组**的形式为：
$$
\{P\} \ S \ \{Q\}
$$
其中：

- **P** 是**前置条件**（Precondition），它描述了在程序段 `S` 执行之前，**程序状态必须满足的条件**。
- **S** 是要执行的**程序代码段**。
- **Q** 是**后置条件**（Postcondition），它描述了在程序段 `S` 执行完毕后，**程序状态应当满足的条件**。

**解释**：如果在执行程序段 `S` 之前前置条件 `P` 成立，那么在执行完 `S` 之后，后置条件 `Q` 应该成立。



**举个例子：**

假设我们有以下简单的程序段 `S`，它将变量 `x` 的值增加 1：

```
x = x + 1;
```

我们可以用一个 Hoare 三元组来表示该程序的执行过程：
$$
\{x = 3\} \ x = x + 1 \ \{x = 4\}
$$


解释为：“如果在执行 `x = x + 1` 之前 `x` 的值为 3，那么在执行完这行代码之后，`x` 的值应为 4。”

### 主要特点和推理规则

Флойда-Хоара логика 提供了几种用于处理不同程序结构的推理规则，如顺序执行、条件语句、循环等。下面是一些关键的推理规则：

#### 顺序执行规则

若有两个 Hoare 三元组：
$$
\{P\} S1 \{R\}

\\

\{R\} S2 \{Q\}
$$
则可以推出：
$$
\{P\} S1 ; S2 \{Q\}
$$


#### 条件语句规则（if-then-else）

对于一个条件语句：

```c
if (B) {
  S1;
} else {
  S2;
}
```

Hoare 三元组为：
$$
\{P\wedge B\} S1 \{Q\}
\\

\{P \wedge \neg B\} \ S2 \ \{Q\}
$$


可以推出：
$$
\{P\} \ \text{if (B)} \ S1 \ \text{else} \ S2 \ \{Q\}
$$


#### 循环不变式（Invariant）和循环规则

循环是程序中最复杂的部分之一，为了验证循环的正确性，Флойда-Хоара логика 引入了**循环不变式**的概念。

例如，考虑以下循环结构：

```c
while (B) {
  S;
}
```

为了验证这个循环的正确性，我们需要找到一个**循环不变式** `I`，该不变式在每次进入和离开循环体时都保持为真。推理规则为：

- **前置条件**：$\{P\} \ \text{while (B)} \ S \ \{Q\}$
- **循环不变式**：在循环的每次迭代开始之前，不变式 `I` 必须成立。
- 推理步骤：
    - **循环前置条件**：在进入循环前，不变式 `I` 应成立。
    - **循环体**：若 `B` 为真，执行 `S` 后，`I` 仍然应为真。
    - **退出条件**：若 `B` 为假，退出循环时，`I` 应能推出后置条件 `Q`。



**举例说明循环不变式：**

考虑一个计算 `n` 的阶乘的程序：

```c
int fact = 1;
int i = 1;
while (i <= n) {
  fact = fact * i;
  i = i + 1;
}
```

不变式 `I` 表示 `fact` 的值为 `1 * 2 * ... * (i - 1)`，且 `i` 介于 `1` 和 `n + 1` 之间。当循环结束时，`i = n + 1`，因此 `fact = n!`。

在该例子中，循环不变式帮助我们验证整个循环是否正确工作。

### 优点

1. **形式化验证**：Флойда-Хоара логика 提供了验证程序的数学基础，可以证明程序满足其规范。
2. **清晰的推理过程**：通过逻辑断言清楚地描述程序的状态变化，特别适用于描述和验证复杂算法的正确性。
3. **自动化**：在现代编程中，霍尔逻辑的许多推理规则可以通过形式化验证工具（如 **ESC/Java**、**Dafny** 等）自动化实现。

### 缺点

1. **循环和递归复杂性**：虽然霍尔逻辑处理顺序程序和简单条件语句相对容易，但对于带有复杂循环和递归的程序，找到适当的不变式可能是困难的。
2. **部分正确性**：霍尔逻辑只证明程序的部分正确性，即程序如果终止，则它满足指定的后置条件。要证明程序总是终止，还需要结合其他技术（如证明程序的**终止性**）。

### 总结

**弗洛伊德-霍尔逻辑** 是一种用于验证程序正确性的形式化方法。通过使用**前置条件**、**后置条件**和**推理规则**，它为程序的部分正确性提供了数学证明的工具。它广泛应用于软件工程和程序验证领域，是形式化方法的重要基础之一。



---

> **CTL 和 LTL 简介**
>
> **CTL（计算树逻辑, Computation Tree Logic）**和**LTL（线性时序逻辑, Linear Temporal Logic）**是两种主要的时序逻辑，它们各自有不同的表达系统状态和行为的方式。

# CTL（Computation Tree Logic）

CTL 是一种分支时序逻辑，它假定**时间是树形**的，**每个状态可以有多个后续状态，也就是每个状态可以有不同的未来分支。**因此，CTL 描述系统时不仅要考虑事件在时间上的顺序，还要考虑它们未来的分支可能性。

## CTL 语法:

CTL 使用**路径量词**和**时序运算符**来表达性质。

- **路径量词:**
    - `A`: 对所有路径 (All paths)
    - `E`: 存在一条路径 (Exists a path)
- **时序运算符:**
    - `X`: 在下一个状态 (ne**X**t)
    - `F`: 在将来的某个状态 (**F**uture/Eventually)
    - `G`: 在所有将来的状态 (**G**lobally)
    - `U`: 直到 (**U**ntil)

### CTL 公式例子:

- `AG p`: 在所有路径上的所有状态中，`p` 都为真（`p` 在所有未来都成立）。
- `EF p`: 存在一条路径，在该路径的某个未来状态，`p` 为真（`p` 在某个未来状态成立）。

CTL 的一个关键特性是它的表达力不仅考虑了单一未来的线性时间，还能够表达不同路径的分支未来。例如，“所有可能的未来中某个状态必须满足条件”是 CTL 能表达的一个经典性质。

# LTL（Linear Temporal Logic）

LTL 假定时间是线性的，即每个状态只有一个未来，它只能表示事件在时间上的顺序，而不考虑不同的未来分支。LTL 关注的是沿着单条路径的系统行为。

## LTL 语法:

LTL 没有**路径量词**，因为它假定只考虑单条路径上的时间演化。LTL 的时序运算符与 CTL 基本相同。

- `X p`: 在下一个状态，`p` 为真。
- `F p`: 在未来的某个状态，`p` 为真。
- `G p`: 在所有未来状态，`p` 为真。
- `p U q`: `p` 一直为真，直到 `q` 为真。

## LTL 公式例子:

- `G p`: 在所有未来状态，`p` 都为真。
- `F p`: 在将来的某个状态，`p` 会为真。

LTL 的焦点是描述系统沿单条执行路径的行为，所以它的表达力集中于线性时间的性质。

---



# **CTL 和 LTL 的比较**

CTL 和 LTL 都是描述系统动态行为的逻辑语言，但它们有一些显著区别：

1. **时间模型**:
    - CTL 使用分支时间模型，能够描述系统在不同未来路径上的行为。
    - LTL 使用线性时间模型，只能描述单条路径上的行为。
2. **表达力**:
    - CTL 能够表达的性质包含不同路径上的分支情况，因此它可以区分不同未来分支，而 LTL 不能。
    - LTL 更擅长描述系统沿一条执行路径的行为，适合线性序列的性质。
3. **公式的不同解释**:
    - CTL 公式 `AF p` 表示“在所有路径中，最终 `p` 都会发生”，即无论哪条路径，`p` 都会在某个状态为真。
    - LTL 公式 `F p` 表示“沿当前路径的某个未来状态，`p` 会为真”。
4. **常见用途**:
    - CTL 通常用于验证系统的“安全性”和“活性”，能够检查所有可能的路径。
    - LTL 则更适合检查系统在特定执行路径上的行为。

## **如何选择 CTL 还是 LTL？**

- 如果你关注的是整个系统的所有可能未来路径，使用 CTL 更合适。CTL 擅长描述系统的不同执行可能性。
- 如果你想描述系统在单条路径上的演化，如某个操作在每次执行的顺序或在某条路径上是否总能达到某个状态，LTL 是一个更简单、直接的选择。

### 模型验证中的应用

在模型验证中，CTL 和 LTL 都被用于检查系统是否满足给定的性质：

- **CTL** 通常使用**符号模型检测**，如用**NuSMV**工具验证系统的所有可能执行路径。
- **LTL** 常用于检查单条执行路径上的行为，可以通过**SPIN**这样的模型验证器来实现。

两者的工具和算法都不相同，基于系统的性质和要求，选择合适的逻辑和工具进行验证非常重要。

如果你有具体的公式或应用场景，我们可以进一步讨论如何用 CTL 或 LTL 来进行表示与验证。



# CTL* (CTL-Star)

**CTL***（CTL-Star，CTL*）是时序逻辑的一种扩展，它结合了 **CTL**（Computation Tree Logic，计算树逻辑）和 **LTL**（Linear Temporal Logic，线性时序逻辑）两者的表达能力。

## CTL* 的背景和动机

CTL 和 LTL 是模型验证中常用的时序逻辑，它们分别用于描述系统的并发和线性时间性质。然而，它们的表达能力存在差异：

- **CTL** 允许通过**路径量词**（如 `A`、`E`）描述系统的分支行为，但对时序运算符的使用是受限的（时序运算符必须与路径量词组合使用）。
- **LTL** 专注于沿单一路径的线性时间演化，能够自由使用时序运算符（如 `X`、`F`、`G`、`U`），但不能处理分支的未来。

为了结合两者的优点，同时增强表达能力，**CTL*** 被提出。CTL* 能同时描述分支和线性时间行为，拥有比 CTL 和 LTL 更强的表达力。

## CTL* 语法

CTL* 的语法允许同时使用 **路径量词** 和 **时序运算符**，并且它允许灵活的嵌套。CTL* 可以描述 LTL 的公式，也可以描述 CTL 的公式，还可以表达 LTL 和 CTL 各自都无法表达的更复杂的时序逻辑。

## CTL* 中的基本符号：

- **原子命题（Atomic Propositions, AP）**：基本的布尔变量，如 `p`、`q`。
- **布尔运算符**：$\neg$（非）、$\wedge$（与）、$\vee$（或）。
- 路径量词：
    - `A`：对所有路径（All paths）。
    - `E`：存在一条路径（Exists a path）。
- 时序运算符：
    - `X p`：下一个状态中，`p` 为真。
    - `F p`：将来的某个状态中，`p` 为真（Eventually）。
    - `G p`：在所有将来的状态中，`p` 为真（Globally）。
    - `p U q`：`p` 一直为真，直到 `q` 为真（Until）。

## CTL* 的公式分为两类：

1. 状态公式（State formulas）：描述某个状态下的性质。
    - 例如：`p`、`¬p`、`p ∧ q` 等。
    - 路径量词可以用于状态公式，如 `A φ` 或 `E φ`，其中 `φ` 是路径公式。
2. 路径公式（Path formulas）：描述路径上的时序行为。
    - 例如：`X p`、`G p`、`p U q` 等。
    - 可以包含状态公式作为子公式，也可以嵌套时序运算符。

### CTL* 的表达力

CTL* 的表达力更强，它可以自由地组合路径量词和时序运算符，而 CTL 和 LTL 都是它的特例：

- **CTL 是 CTL\* 的子集**：在 CTL 中，时序运算符必须与路径量词（`A` 或 `E`）结合使用，例如 `AX p`、`EG p`。这意味着 CTL 的每个时序运算符都限定在分支结构中，而不能单独存在。
- **LTL 是 CTL\* 的子集**：在 LTL 中，我们只关心单条路径上的时序演化，所以 LTL 是在 CTL* 中去掉了路径量词的情况，也就是所有 LTL 公式可以看作是 CTL* 中默认的路径公式。

### CTL* 的例子

1. **LTL 公式可以通过 CTL\* 表示**：
    - LTL 公式 `G F p`（“在所有未来的时间里，`p` 事件会重复发生”）可以表示为 CTL* 中的路径公式 `A[G F p]`，即在所有路径上，`p` 会一直最终发生。
2. **CTL 公式可以通过 CTL\* 表示**：
    - CTL 公式 `EF p`（“存在一条路径，`p` 最终会在某个状态为真”）可以用 CTL* 表示为 `E[F p]`。
3. **CTL\* 的表达能力超越 CTL 和 LTL**：
    - 公式 `E[G F p]` 表示“存在一条路径，在该路径上 `p` 事件无限次地重复发生”。这个公式不能用纯粹的 CTL 或 LTL 表达，但 CTL* 能够表达这样的混合性质。

### 总结

- **CTL*** 是时序逻辑的扩展，结合了 CTL 和 LTL 的优点，能够表达更复杂的系统行为。它通过允许路径量词和时序运算符的自由组合，能够处理分支和线性时间的复杂性质。
- **CTL 是 CTL\* 的子集**，它只允许时序运算符与路径量词组合使用，限制了表达自由度。
- **LTL 是 CTL\* 的另一个子集**，它专注于单一路径上的时序行为，不考虑路径分支。

CTL* 的强大之处在于它的通用性，适用于描述系统中既有分支行为，又有时间序列的复杂性质。在实际的模型验证中，CTL* 由于其复杂性，尽管理论上表达能力最强，但通常因为其高复杂度而不如 CTL 和 LTL 常用。